# DECISIONS

1. Backend на Express

- Для backend выбран чистый Express без heavyweight‑фреймворков.
- Это даёт полный контроль над маршрутизацией, слоями приложения и кодом обработки гонки.

2. SQLite в качестве БД

- SQLite выбрана для простоты локального запуска и отсутствия зависимости от отдельного сервера БД.
- Файл БД хранится рядом с backend и может использоваться как при запуске напрямую, так и внутри Docker.

3. Слоистая архитектура backend

- Backend разделён на слои:
  - `repositories` для работы с БД
  - `services` для бизнес‑логики и валидации
  - `routes` для HTTP‑эндпоинтов
  - `middleware` для авторизации и ролей
- Это упрощает тестирование и развитие функционала (например, логика гонки находится в сервисе/репозитории заявок).

4. Упрощённая авторизация через заголовок

- Для минимизации сложности авторизация реализована через заголовок `x-user-id`.
- Роль (`dispatcher` или `master`) берётся из таблицы `users`, а доступ контролируется middleware `requireRole`.
- Такой подход подходит для тестового задания и легко подкладывается под UI с выбором пользователя.

5. Защита от гонки «Взять в работу»

- Логика реализована через условный `UPDATE` в репозитории:
  - переход в `in_progress` возможен только из `assigned` и только для назначенного мастера
  - если `UPDATE` не затронул ни одной строки, сервис генерирует ошибку `409`
- Такой подход не требует явных блокировок и хорошо работает с SQLite.

6. Использование Jest для тестов backend

- Для backend выбран Jest как стандартный инструмент тестирования в Node.js‑проектах.
- Тесты работают с отдельной in‑memory SQLite‑базой, что делает их быстрыми и независимыми от данных разработки.

7. Docker Compose для локального запуска

- Для удобства проверки реализован запуск через `docker-compose.yml`.
- В составе: два сервиса (`backend` и `frontend`) на базе образа Node 20 LTS.
- Это позволяет запускать приложение «одной командой» без ручной установки Node на машине проверяющего.

